import{_ as s,c as e,o as a,Q as n}from"./chunks/framework.5f28ab71.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"reactivity/ref/05-源码阅读-ref简单数据类型的响应性.md","lastUpdated":1709451841000}'),o={name:"reactivity/ref/05-源码阅读-ref简单数据类型的响应性.md"},l=n(`<h2 id="_05-源码阅读-ref-简单数据类型的响应性" tabindex="-1">05-源码阅读-ref 简单数据类型的响应性 <a class="header-anchor" href="#_05-源码阅读-ref-简单数据类型的响应性" aria-label="Permalink to &quot;05-源码阅读-ref 简单数据类型的响应性&quot;">​</a></h2><p>接下来，我们将来看一下：<code>ref</code> 针对简单数据类型的响应性。</p><p>和之前一样我们需要先创建对应的测试案例：</p><ol><li><p>我们创建如下测试案例 创建测试实例 <code>packages/vue/examples/imooc/ref-shallow.html</code>：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> ref</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> effect </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Vue</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">张三</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 调用 effect 方法</span></span>
<span class="line"><span style="color:#82AAFF;">effect</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">#app</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerText</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">李四</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2000</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li></ol><p>该测试案例，利用 <code>ref</code> 创建了一个 <strong>简单数据类型</strong> 的响应性。那么我们接下来就借助该案例，来看下 <code>vue3</code> 对简单数据类型的响应性的处理。</p><h3 id="ref-函数" tabindex="-1">ref 函数 <a class="header-anchor" href="#ref-函数" aria-label="Permalink to &quot;ref 函数&quot;">​</a></h3><p>整个 <code>ref</code> 初始化的流程与之前完全相同，但是有一个不同的地方，需要 <strong>特别注意</strong>：因为当前不是复杂数据类型，所以在 <code>toReactive</code> 函数中，不会通过 <code>reactive</code> 函数处理 <code>value</code>。所以 <code>this._value</code> <strong>不是</strong> 一个 <code>proxy</code>。即：<strong>无法监听 <code>setter</code> 和 <code>getter</code></strong>。</p><h3 id="effect-函数" tabindex="-1">effect 函数 <a class="header-anchor" href="#effect-函数" aria-label="Permalink to &quot;effect 函数&quot;">​</a></h3><p>整个 <code>effect</code> 函数的流程与之前完全相同。</p><h3 id="get-value" tabindex="-1">get value() <a class="header-anchor" href="#get-value" aria-label="Permalink to &quot;get value()&quot;">​</a></h3><p>整个 <code>effect</code> 函数中引起的 <code>get value()</code> 的流程与之前完全相同。</p><h3 id="大不同-set-value" tabindex="-1">大不同：set value() <a class="header-anchor" href="#大不同-set-value" aria-label="Permalink to &quot;大不同：set value()&quot;">​</a></h3><p>延迟两秒钟，我们将要执行 <code>obj.value = &#39;李四&#39;</code> 的逻辑。我们知道在复杂数据类型下，这样的操作（<code>obj.value.name = &#39;李四&#39;</code>），其实是触发了 <code>get value</code> 行为。</p><p>但是，此时，在 简单数据类型之下，<code>obj.value = &#39;李四&#39;</code> 触发的将是 <code>set value</code> 形式，这里也是 <strong><code>ref</code> 可以监听到简单数据类型响应性的关键。</strong></p><ol><li>跟踪代码，进入到<code>set value(newVal)</code><ol><li>通过 <code>hasChanged</code> 方法，对比数据是否发生变化</li><li>发生变化，则触发<code>triggerRefValue</code>，进入： <ol><li>执行 <code>triggerEffects</code> 触发依赖，完成响应性</li></ol></li></ol></li></ol><p>由以上代码可知：</p><ol><li>简单数据类型的响应性，不是基于 <code>proxy</code> 或 <code>Object.defineProperty</code> 进行实现的，而是通过：<strong><code>set</code> 语法，将对象属性绑定到查询该属性时将被调用的函数</strong> 上，使其触发 <code>xxx.value = &#39;李四&#39;</code> 属性时，其实是调用了 <code>xxx.value(&#39;李四&#39;)</code> 函数。</li><li>在 <code>value</code> 函数中，触发依赖</li></ol><p>所以，我们可以说：对于 <code>ref</code> 标记的简单数据类型而言，它其实 <strong>“并不具备响应性”</strong>，所谓的响应性只不过是因为我们 <strong>主动触发了 <code>value</code> 方法</strong> 而已。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>目前我们已经明确了 <code>ref</code> 针对于简单数据类型的 “响应性” 的问题，那么下面我们就可以针对我们的理解，来对这一块进行对应的实现了。</p>`,20),p=[l];function c(t,r,d,i,D,y){return a(),e("div",null,p)}const A=s(o,[["render",c]]);export{u as __pageData,A as default};
