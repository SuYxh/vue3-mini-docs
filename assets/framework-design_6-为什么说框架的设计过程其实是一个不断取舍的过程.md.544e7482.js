import{_ as o,c as t,o as e,Q as _}from"./chunks/framework.5f28ab71.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"framework-design/6-为什么说框架的设计过程其实是一个不断取舍的过程.md","lastUpdated":1709451841000}'),r={name:"framework-design/6-为什么说框架的设计过程其实是一个不断取舍的过程.md"},s=_('<h2 id="_6-为什么说框架的设计过程其实是一个不断取舍的过程" tabindex="-1">6-为什么说框架的设计过程其实是一个不断取舍的过程？ <a class="header-anchor" href="#_6-为什么说框架的设计过程其实是一个不断取舍的过程" aria-label="Permalink to &quot;6-为什么说框架的设计过程其实是一个不断取舍的过程？&quot;">​</a></h2><p><code>Vue</code> 作者尤雨溪在一次演讲中说道：<strong>框架的设计过程其实是一个不断取舍的过程</strong> 。</p><p>这代表的是什么意思呢？</p><p>想要搞明白这个，那么再来明确一下之前说过的概念：</p><ol><li>命令式的性能 &gt; 声明式的性能</li><li>命令式的可维护性 &lt; 声明式的可维护性</li><li>声明式的框架本质上是由命令式的代码来去实现的</li><li>企业项目开发时，大多使用声明式框架</li></ol><p>当我们明确好了这样的一个问题之后，那么我们接下来来思考一个问题：<strong>框架的开发与设计原则是什么呢？</strong></p><p>我们知道对于 <code>Vue</code> 而言，当我们使用它的是通过 <strong>声明式</strong> 的方式进行使用，但是对于 <code>Vue</code> 内部而言，是通过 <strong>命令式</strong> 来进行的实现。</p><p>所以我们可以理解为：<strong>Vue 封装了命令式的逻辑，而对外暴露出了声明式的接口</strong></p><p>那么既然如此，我们明知 <strong>命令式的性能 &gt; 声明式的性能</strong> 。那么 <code>Vue</code> 为什么还要选择声明式的方案呢？</p><p>其实原因非常的简单，那就是因为：<strong>命令式的可维护性 &lt; 声明式的可维护性</strong> 。</p><blockquote><p>为指定的 div 的子元素 div 的子元素 p 标签，展示变量 msg</p></blockquote><p>以这个例子为例。</p><p>对于开发者而言，不需要关注实现过程，只需要关注最终的结果即可。</p><p>而对于 <code>Vue</code> 而言，他所需要做的就是：封装命令式逻辑，同时 **尽可能的减少性能的损耗！**它需要在 <strong>性能</strong> 与 <strong>可维护性</strong> 之间，找到一个平衡。从而找到一个 <strong>可维护性更好，性能相对更优</strong> 的一个点。</p><p>所以对于 <code>Vue</code> 而言，它的设计原则就是：<strong>在保证可维护性的基础上，尽可能的减少性能的损耗</strong>。</p><p>那么回到我们的标题：为什么说框架的设计过程其实是一个不断取舍的过程？因为：</p><p>我们需要在可维护性和性能之间，找到一个平衡点。在保证可维护性的基础上，尽可能的减少性能的损耗。所以框架的设计过程其实是一个不断在 <strong>可维护性和性能</strong> 之间进行取舍的过程</p>',17),n=[s];function p(a,c,d,g,i,l){return e(),t("div",null,n)}const f=o(r,[["render",p]]);export{m as __pageData,f as default};
