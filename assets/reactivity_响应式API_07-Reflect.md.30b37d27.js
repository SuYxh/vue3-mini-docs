import{_ as s,c as e,o as a,Q as n}from"./chunks/framework.5f28ab71.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"reactivity/响应式API/07-Reflect.md","lastUpdated":1709451841000}'),l={name:"reactivity/响应式API/07-Reflect.md"},p=n(`<h2 id="_07-reflect" tabindex="-1">07-Reflect <a class="header-anchor" href="#_07-reflect" aria-label="Permalink to &quot;07-Reflect&quot;">​</a></h2><p>当我们了解了 <code>Proxy</code> 之后，那么接下来我们需要了解另外一个 <code>Proxy</code> 的 “伴生对象”：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noreferrer">Reflect</a></p><p><code>Reflect</code> 属性,多数时候会与 <code>proxy</code> 配合进行使用。在 <code>MDN</code> <code>Proxy</code> 的例子中，<code>Reflect</code> 也有对此出现。</p><p>那么 <code>Reflect</code> 的作用是什么呢？</p><p>查看 <code>MDN</code> 的文档介绍，我们可以发现 <code>Reflect</code> 提供了非常多的静态方法，并且很巧的是这些方法与 <code>Proxy</code> 中 <code>Handler</code> 的方法类似：</p><blockquote><h2 id="reflect-静态方法" tabindex="-1">Reflect <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" target="_blank" rel="noreferrer">静态方法</a> <a class="header-anchor" href="#reflect-静态方法" aria-label="Permalink to &quot;Reflect [静态方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect#静态方法)&quot;">​</a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get" target="_blank" rel="noreferrer"><code>Reflect.get(target, propertyKey[, receiver\\])</code></a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/has" target="_blank" rel="noreferrer"><code>Reflect.has(target, propertyKey)</code></a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/set" target="_blank" rel="noreferrer"><code>Reflect.set(target, propertyKey, value[, receiver\\])</code></a></p><p>…</p><h2 id="handler-对象的方法" tabindex="-1"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy#handler_%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95" target="_blank" rel="noreferrer">handler 对象的方法</a> <a class="header-anchor" href="#handler-对象的方法" aria-label="Permalink to &quot;[handler 对象的方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy#handler_对象的方法)&quot;">​</a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/has" target="_blank" rel="noreferrer"><code>handler.has()</code></a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get" target="_blank" rel="noreferrer"><code>handler.get()</code></a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set" target="_blank" rel="noreferrer"><code>handler.set()</code></a></p><p>…</p></blockquote><p>那么 <code>Reflect</code> 中 <code>get</code> 和 <code>set</code> 的作用是什么呢？</p><p>我们来看一下代码：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  const obj = </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    name: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">张三</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(obj.name) // 张三</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(Reflect.get(obj, &#39;name&#39;)) // 张三</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>由以上代码可以发现，两次打印的结果是相同的。这其实也就说明了 <code>Reflect.get(obj, &#39;name&#39;)</code> 本质上和 <code>obj.name</code> 的作用 <strong>相同</strong></p><p>那么既然如此，我们为什么还需要 <code>Reflect</code> 呢？</p><p>根据官方文档可知，对于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get" target="_blank" rel="noreferrer">Reflect.get</a> 而言，它还存在第三个参数 <code>receiver</code>，那么这个参数的作用是什么呢？</p><p>根据官网的介绍为：</p><blockquote><p>如果<code>target</code>对象中指定了<code>getter</code>，<code>receiver</code>则为<code>getter</code>调用时的<code>this</code>值。</p></blockquote><p>什么意思呢？我们来看以下代码：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  const p1 = </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    lastName: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">张</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    firstName: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">三</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 通过 get 标识符标记，可以让方法的调用像属性的调用一样</span></span>
<span class="line"><span style="color:#A6ACCD;">    get </span><span style="color:#82AAFF;">fullName</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      return this.lastName + this.firstName</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  const p2 = </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    lastName: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">李</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    firstName: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">四</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 通过 get 标识符标记，可以让方法的调用像属性的调用一样</span></span>
<span class="line"><span style="color:#A6ACCD;">    get </span><span style="color:#82AAFF;">fullName</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      return this.lastName + this.firstName</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(p1.fullName) // 张三</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(Reflect.get(p1, &#39;fullName&#39;)) // 张三</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 第三个参数 receiver 在对象指定了 getter 时表示为 this</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(Reflect.get(p1, &#39;fullName&#39;, p2)) // 李四</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>在以上代码中，我们可以利用 <code>p2</code> 作为第三个参数 <code>receiver</code> ，以此来修改 <code>fullName</code> 的打印结果。即：<strong>此时触发的 <code>fullName</code> 不是 <code>p1</code> 的 而是 <code>p2</code> 的</strong>。</p><p>那么明确好了这个之后，我们再来看下面这个例子：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  const p1 = </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    lastName: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">张</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    firstName: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">三</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 通过 get 标识符标记，可以让方法的调用像属性的调用一样</span></span>
<span class="line"><span style="color:#A6ACCD;">    get </span><span style="color:#82AAFF;">fullName</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      return this.lastName + this.firstName</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  const proxy = new Proxy(p1, </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// target：被代理对象</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// receiver：代理对象</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">get</span><span style="color:#A6ACCD;">(target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> receiver) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      console.log(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">触发了 getter</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">);</span></span>
<span class="line"><span style="color:#F07178;">      return target[key]</span></span>
<span class="line"><span style="color:#F07178;">    }</span></span>
<span class="line"><span style="color:#F07178;">  })</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  console.log(proxy.fullName);</span></span>
<span class="line"><span style="color:#F07178;">&lt;/script&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>在以上这个代码中，我问大家，此时我们触发了 <code>prox.fullName</code>，在这个 <code>fullName</code> 中又触发了 <code>this.lastName + this.firstName</code> 那么问：<strong>getter 应该被触发几次？</strong></p><p><strong>此时 <code>getter</code> 应该被触发 3 次！</strong> ，但是 <strong>实际只触发了 1 次！</strong> 。为什么？</p><p>可能有同学已经想到了，因为在 <code>this.lastName + this.firstName</code> 这个代码中，我们的 <code>this</code> 是 <code>p1</code> ，<strong>而非 <code>proxy</code></strong> ！所以 <code>lastName</code> 和 <code>firstName</code> 的触发，不会再次触发 <code>getter</code>。</p><p>那么怎么办呢？我们如何能够让 <code>getter</code> 被触发三次？</p><p>想要实现这个想过，那么就需要使用到 <code>Reflect.get</code> 了。</p><p>我们已知，<code>Reflect.get</code> 的第三个参数 <code>receiver</code> 可以修改 <code>this</code> 指向，那么我们可不可以 <strong>利用 Reflect.get 把 fullName 中的 this 指向修改为 proxy</strong>，依次来达到触发三次的效果？</p><p>我们修改以上代码：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proxy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Proxy</span><span style="color:#A6ACCD;">(p1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// target：被代理对象</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// receiver：代理对象</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">get</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">key</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">receiver</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">触发了 getter</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// return target[key]</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Reflect</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">receiver</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>修改代码之后，我们发现，此时 <code>getter</code> 得到了三次的触发！</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>当我们期望监听代理对象的 <code>getter</code> 和 <code>setter</code> 时，<strong>不应该使用 <code>target[key]</code></strong>，因为它在某些时刻（比如 <code>fullName</code>）下是不可靠的。而 <strong>应该使用 <code>Reflect</code></strong> ，借助它的 <code>get</code> 和 <code>set</code> 方法，使用 <code>receiver（proxy 实例）</code> 作为 <code>this</code>，已达到期望的结果（触发三次 <code>getter</code>）。</p>`,30),o=[p];function r(c,t,i,y,D,d){return a(),e("div",null,o)}const C=s(l,[["render",r]]);export{F as __pageData,C as default};
