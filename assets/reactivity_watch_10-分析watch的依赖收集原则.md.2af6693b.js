import{_ as e,c as t,o,Q as c}from"./chunks/framework.5f28ab71.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"reactivity/watch/10-分析watch的依赖收集原则.md","lastUpdated":1709451841000}'),a={name:"reactivity/watch/10-分析watch的依赖收集原则.md"},r=c('<h2 id="_10-问题分析-watch-下的依赖收集原则" tabindex="-1">10-问题分析-watch 下的依赖收集原则 <a class="header-anchor" href="#_10-问题分析-watch-下的依赖收集原则" aria-label="Permalink to &quot;10-问题分析-watch 下的依赖收集原则&quot;">​</a></h2><p>现在我们还差一步就可以完成 <code>watch</code> 的响应式数据监听了，那么这一步是什么呢？</p><p>根据代码可知，<code>watch</code> 内部本质上也是通过：<code>ReactiveEffect + scheduler</code> 进行实现的。</p><p>那么对于 <code>ReactiveEffect</code> 而言，我们知道，他需要拥有两个先决条件才可以完成响应性：</p><ol><li>依赖收集</li><li>触发依赖</li></ol><p>那么对于我们当前的代码而言，我们在 <code>setTimeout</code> 中，触发了 <strong>触发依赖</strong> 操作。但是我们在哪里进行的 <strong>依赖收集呢？</strong></p><p>答案是：<strong>没有</strong></p><p>这就是我们为什么没有办法触发 <code>watch</code> 监听的原因。</p><p>那么这个依赖收集我们应该怎么做呢？</p><p>不知道大家还记不记得，我们之前在看源码的时候，看到过一个 <code>traverse</code> 方法。</p><p>之前的时候，我们一直没有看过该方法，那么现在我们可以来说一下它了。</p><p>它的源码在 <code>packages/runtime-core/src/apiWatch.ts</code> 中：</p><p>查看源代码可以发现，这里面的代码其实有些 <strong>莫名其妙</strong>，他好像什么都没有做，只是在 <strong>循环的进行 <code>xxx.value</code></strong> 的形式，我们知道 <code>xxx.value</code> 这个行为，我们把它叫做 <strong><code>getter</code></strong> 行为。并且这样会产生 <strong>副作用</strong>，那就是 <strong>依赖收集！</strong>。</p><p>所以我们知道了，对于 <code>traverse</code> 方法而言，它就是一个不断在触发响应式数据 <strong>依赖收集</strong> 的方法。</p><p>我们可以通过该方法来触发依赖收集，然后在两秒之后，触发依赖，完成 <code>scheduler</code> 的回调。</p>',15),s=[r];function d(n,p,_,i,h,l){return o(),t("div",null,s)}const f=e(a,[["render",d]]);export{u as __pageData,f as default};
