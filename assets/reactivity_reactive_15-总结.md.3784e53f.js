import{_ as e,c as o,o as c,Q as t}from"./chunks/framework.5f28ab71.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"reactivity/reactive/15-总结.md","lastUpdated":1709451841000}'),d={name:"reactivity/reactive/15-总结.md"},a=t('<h2 id="_15-总结" tabindex="-1">15-总结 <a class="header-anchor" href="#_15-总结" aria-label="Permalink to &quot;15-总结&quot;">​</a></h2><p>我们初次解除了 <code>reactivity</code> 模块，并且在该模块中构建了 <code>reactive</code> 响应性函数。</p><p>对于 <code>reactive</code> 的响应性函数而言，我们知道它：</p><ol><li>是通过 <code>proxy</code> 的 <code>setter</code> 和 <code>getter</code> 来实现的数据监听</li><li>需要配合 <code>effect</code> 函数进行使用</li><li>基于 <code>WeakMap</code> 完成的依赖收集和处理</li><li>可以存在一对多的依赖关系</li></ol><p>同时我们也了解了 <code>reactive</code> 函数的不足：</p><ol><li><code>reactive</code> 只能对 <strong>复杂数据</strong> 类型进行使用</li><li><code>reactive</code> 的响应性数据，不可以进行解构</li></ol><p>因为 <code>reactive</code> 的不足，所以 <code>vue 3</code> 又为我们提供了 <code>ref</code> 函数构建响应性，那么：</p><ol><li><code>ref</code> 函数的内容是如何进行实现的呢？</li><li><code>ref</code> 可以构建简单数据类型的响应性吗？</li><li>为什么 <code>ref</code> 类型的数据，必须要通过 <code>.value</code> 访问值呢？</li></ol><p>带着以上三个问题，我们来看下一章 <strong><code>ref</code> 的响应性</strong></p>',9),i=[a];function r(l,_,s,n,p,f){return c(),o("div",null,i)}const m=e(d,[["render",r]]);export{h as __pageData,m as default};
