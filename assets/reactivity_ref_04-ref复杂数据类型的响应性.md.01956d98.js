import{_ as s,c as e,o as a,Q as o}from"./chunks/framework.5f28ab71.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"reactivity/ref/04-ref复杂数据类型的响应性.md","lastUpdated":1709451841000}'),n={name:"reactivity/ref/04-ref复杂数据类型的响应性.md"},l=o(`<h2 id="_04-ref-复杂数据类型的响应性" tabindex="-1">04-ref 复杂数据类型的响应性 <a class="header-anchor" href="#_04-ref-复杂数据类型的响应性" aria-label="Permalink to &quot;04-ref 复杂数据类型的响应性&quot;">​</a></h2><p>根据以上代码实现我们知道，针对于 <code>ref</code> 的复杂数据类型而言，它的响应性本身，其实是 <strong>利用 <code>reactive</code> 函数</strong> 进行的实现，即：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">张三</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">张三</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>本质上的实现方案其实是完全相同的，都是利用 <code>reactive</code> 函数，返回一个 <code>proxy</code> 实例，监听 <code>proxy</code> 的 <code>getter</code> 和 <code>setter</code> 进行的依赖收集和依赖触发。</p><p>但是它们之间也存在一些不同的地方，比如：</p><ol><li><code>ref</code><ol><li><code>ref</code> 的返回值是一个 <code>RefImpl</code> 类型的实例对象</li><li>想要访问 <code>ref</code> 的真实数据，需要通过 <code>.value</code> 来触发 <code>get value</code> 函数，得到被 <code>toReactive</code> 标记之后的 <code>this._value</code> 数据，即：<code>proxy</code> 实例</li></ol></li><li><code>reactive</code><ol><li><code>reactive</code> 会直接返回一个 <code>proxy</code> 的实例对象，不需要通过 <code>.value</code> 属性得到</li></ol></li></ol><p>同时我们也知道，对于 <code>reactive</code> 而言，它是不具备 <strong>简单数据类型</strong> 的响应性呢，但是 <code>ref</code> 是具备的。</p><p>那么 <code>ref</code> 是如何处理 <strong>简单数据类型</strong> 的响应性的呢？</p>`,8),p=[l];function c(r,t,d,i,D,y){return a(),e("div",null,p)}const A=s(n,[["render",c]]);export{F as __pageData,A as default};
