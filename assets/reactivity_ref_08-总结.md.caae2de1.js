import{_ as e,c as o,o as c,Q as d}from"./chunks/framework.5f28ab71.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"reactivity/ref/08-总结.md","lastUpdated":1709451841000}'),t={name:"reactivity/ref/08-总结.md"},r=d('<h2 id="_08-总结" tabindex="-1">08-总结 <a class="header-anchor" href="#_08-总结" aria-label="Permalink to &quot;08-总结&quot;">​</a></h2><p>那么到这里我们就已经完成了 <code>ref</code> 响应性函数的构建，那么大家还记不记得开篇时所问的三个问题：</p><ol><li><code>ref</code> 函数是如何进行实现的呢？</li><li><code>ref</code> 可以构建简单数据类型的响应性吗？</li><li>为什么 <code>ref</code> 类型的数据，必须要通过 <code>.value</code> 访问值呢？</li></ol><p>大家现在再次面对这三个问题，是否能够回答出来呢？</p><ol><li><p>问题一：<code>ref</code>函数是如何进行实现的呢？</p><p><code>ref</code> 函数本质上是生成了一个 <code>RefImpl</code> 类型的实例对象，通过 <code>get</code> 和 <code>set</code> 标记处理了 <code>value</code> 函数</p></li><li><p>问题二：<code>ref</code>可以构建简单数据类型的响应性吗？</p><p>是的。<code>ref</code> 可以构建简单数据类型的响应性</p></li><li><p>问题三：为什么<code>ref</code>类型的数据，必须要通过<code>.value</code>访问值呢？</p><ol><li>因为 <code>ref</code> 需要处理简单数据类型的响应性，但是对于简单数据类型而言，它无法通过 <code>proxy</code> 建立代理。</li><li>所以 <code>vue</code> 通过 <code>get value()</code> 和 <code>set value（）</code> 定义了两个属性函数，通过 <strong>主动</strong> 触发这两个函数（属性调用）的形式来进行 <strong>依赖收集</strong> 和 <strong>触发依赖</strong></li><li>所以我们必须通过 <code>.value</code> 来保证响应性。</li></ol></li></ol>',5),l=[r];function a(i,_,s,p,n,f){return c(),o("div",null,l)}const h=e(t,[["render",a]]);export{v as __pageData,h as default};
