import{_ as e,c as o,o as t,Q as a}from"./chunks/framework.5f28ab71.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"reactivity/reactive/08-track和trigger分析.md","lastUpdated":1709451841000}'),s={name:"reactivity/reactive/08-track和trigger分析.md"},c=a(`<h2 id="_08-track-和-trigger-分析" tabindex="-1">08-track 和 trigger 分析 <a class="header-anchor" href="#_08-track-和-trigger-分析" aria-label="Permalink to &quot;08-track 和 trigger 分析&quot;">​</a></h2><p>根据我们在 <code>packages/reactivity/src/baseHandlers.ts</code> 中的代码可知，当触发 <code>getter</code> 行为时，其实我们会触发 <code>track</code> 方法，进行 <strong>依赖收集</strong>，当触发 <code>setter</code> 行为时，会触发 <code>trigger</code> 方法，来 <strong>触发依赖</strong></p><p>那么这里就涉及到了两个概念：</p><ol><li>依赖收集：<code>track</code></li><li>触发依赖：<code>trigger</code></li></ol><p>所以接下来如果我们想要实现这两个函数，那么就需要先搞清楚什么是 <strong>依赖收集</strong> 和 <strong>触发依赖</strong>。</p><h3 id="什么是响应性" tabindex="-1">什么是响应性 <a class="header-anchor" href="#什么是响应性" aria-label="Permalink to &quot;什么是响应性&quot;">​</a></h3><p>在之前的源码学习中，我们知道所谓的响应性其实指的就是：<strong>当响应性数据触发 <code>setter</code> 时执行 <code>fn</code> 函数</strong></p><p>那么想要达到这样的一个目的，那就必须要在：<strong><code>getter</code> 时能够收集当前的 <code>fn</code> 函数，以便在 <code>setter</code> 的时候可以执行对应的 <code>fn</code> 函数</strong></p><p>但是对于收集而言，如果仅仅是把 <code>fn</code> 存起来还是不够的，我们还需要知道，当前的这个 <code>fn</code> 是<strong>哪个响应式数据对象</strong>的<strong>哪个属性</strong>对应的，只有这样，我们才可以在 <strong>该属性</strong> 触发 <code>setter</code> 的时候，准确的执行响应性。</p><p>那么我们应该如何确定以这一点呢？</p><h3 id="如何进行依赖收集" tabindex="-1">如何进行依赖收集 <a class="header-anchor" href="#如何进行依赖收集" aria-label="Permalink to &quot;如何进行依赖收集&quot;">​</a></h3><p>在 <code>packages/reactivity/src/reactive.ts</code> 中创建过一个 <code>WeakMap</code>：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> reactiveMap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">WeakMap</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">object</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>我们知道 <code>WeakMap</code> 它的 <code>key</code> 必须是一个对象，并且 <code>key</code> 是一个弱引用的。</p><p>那么大家想一想我们可不可以这样：</p><ol><li><code>WeakMap</code><ol><li><code>key</code>：响应性对象</li><li><code>value</code>：<code>Map</code>对象 <ol><li><code>key</code>：响应性对象的指定属性</li><li><code>value</code>：指定对象的指定属性的 执行函数</li></ol></li></ol></li></ol><p>图表表示：</p><p><img src="https://qn.huat.xyz/mac/202403022027664.jpg" alt="图片描述"></p><p>那么这样我们就可以关联上 <strong>指定对象的指定属性</strong> 与 <strong>执行函数 <code>fn</code></strong> 之间的关系，当触发 <code>setter</code> 时，直接执行 <strong>对应对象的对应属性的 <code>fn</code></strong> 即可。</p><p>那么明确好了这样的一个概念之后，接下来我们就可以根据以上理念进行对应的实现。</p>`,20),r=[c];function n(l,p,d,i,g,_){return t(),o("div",null,r)}const k=e(s,[["render",n]]);export{h as __pageData,k as default};
