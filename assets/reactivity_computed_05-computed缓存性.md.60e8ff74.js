import{_ as s,c as n,o as e,Q as o}from"./chunks/framework.5f28ab71.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"reactivity/computed/05-computed缓存性.md","lastUpdated":1709451841000}'),a={name:"reactivity/computed/05-computed缓存性.md"},l=o(`<h2 id="_05-computed-缓存性" tabindex="-1">05-computed 缓存性 <a class="header-anchor" href="#_05-computed-缓存性" aria-label="Permalink to &quot;05-computed 缓存性&quot;">​</a></h2><p>我们知道 <code>computed</code> 区别于 <code>function</code> 最大的地方就是：<strong>computed 具备缓存</strong>，当多次触发计算实行时，那么计算属性只会计算 <strong>一次</strong>。</p><p>那么秉承着这样的一个理念，我们来创建一个测试用例：</p><ol><li><p>创建 <code>packages/vue/examples/reactivity/computed-cache.html</code>：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> reactive</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> computed</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> effect </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Vue</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">张三</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> computedObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">computed</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">计算属性执行计算</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">姓名：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">effect</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">#app</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerHTML</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">computedObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">#app</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerHTML</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">computedObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">李四</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2000</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></li></ol><p>运行到浏览器，我们发现当前代码出现了 <strong>死循环</strong> 的问题。</p><p>那么这个 <strong>死循环</strong> 是因为什么呢？</p><p>如果我们想要实现计算属性的缓存性，又应该如何进行实现呢？</p><p>带着这两个问题，我们继续来往下看。</p><h3 id="为什么会出现死循环" tabindex="-1">为什么会出现死循环 <a class="header-anchor" href="#为什么会出现死循环" aria-label="Permalink to &quot;为什么会出现死循环&quot;">​</a></h3><p>我们为当前的代码进行 <code>debugger</code>，查看出现该问题的原因。我们知道这个死循环是在 <strong>延迟两秒后</strong> 出现的，而延迟两秒之后是 <code>obj.name</code> 的调用，即： <code>reactive</code> 的 <code>getter</code> 行为被触发，也就是 <code>trigger</code> 方法触发时：</p><ol><li><p>为 <code>packages/reactivity/src/effect.ts</code> 中的 <code>trigger</code> 方法增加断点，延迟两秒之后，进入断点：</p></li><li><p>此时执行的代码是 <code>obj.name = &#39;李四&#39;</code>，所以在 <code>target</code> 为 <code>{name: &#39;李四&#39;}</code></p></li><li><p>但是要 <strong>注意</strong>，此时 <code>targetMap</code> 中，已经在 <strong>收集过 <code>effect</code></strong> 了，此时的 <code>dep</code> 中包含一个 <strong>计算属性</strong>的 <code>effect</code> ：</p></li></ol><p><img src="https://qn.huat.xyz/mac/202403022302119.jpg" alt="图片描述"></p><ol start="4"><li><p>代码继续向下进行，进入 <code>triggerEffects(dep)</code> 方法</p></li><li><p>在 <code>triggerEffects(dep)</code> 方法中，继续进入 <code>triggerEffect(effect)</code></p></li><li><p>在 <code>triggerEffect</code> 中接收到的 <code>effect</code>，即为刚才查看的 <strong>计算属性的 <code>effect</code>：</strong></p></li></ol><p><img src="https://qn.huat.xyz/mac/202403022302808.jpg" alt="图片描述"></p><ol start="7"><li><p>此时因为 <code>effect</code> 中存在 <code>scheduler</code>，所以会执行该计算属性的 <code>scheduler</code> 函数，在 <code>scheduler</code> 函数中，会触发 <code>triggerRefValue(this)</code>，而 <code>triggerRefValue</code> 则会再次触发 <code>triggerEffects</code>。</p></li><li><p><strong>特别注意：</strong> 此时 <code>effects</code> 的值为 <strong>计算属性实例的 <code>dep</code></strong>：</p></li></ol><p><img src="https://qn.huat.xyz/mac/202403022302032.jpg" alt="图片描述"></p><ol start="9"><li><p>循环 <code>effects</code>，从而再次进入 <code>triggerEffect</code> 中。</p></li><li><p><strong>再次进入 <code>triggerEffect</code></strong>，此时 <code>effect</code> 为 <strong>非计算属性的 <code>effect</code></strong>，即 <strong><code>fn</code> 函数</strong>：</p></li></ol><p><img src="https://qn.huat.xyz/mac/202403022302185.jpg" alt="图片描述"></p><ol start="11"><li><p>因为他 <strong>不是</strong> 计算属性的 <code>effect</code> ，所以会直接执行 <code>run</code> 方法。</p></li><li><p>而我们知道 <code>run</code> 方法中，其实就是触发了 <code>fn</code> 函数，所以最终会执行：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">#app</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerHTML</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">computedObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">#app</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerHTML</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">computedObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li><li><p>但是在这个 <code>fn</code> 函数中，是有触发 <code>computedObj.value</code> 的，而 <code>computedObj.value</code> 其实是触发了 <code>computed</code> 的 <code>get value</code> 方法。</p></li><li><p>那么这次 <code>run</code> 的执行会触发 <strong>两次 <code>computed</code> 的 <code>get value</code></strong></p></li><li><ol><li>第一次进入： <ol><li>进入 <code>computed</code> 的 <code>get value</code> ：</li><li>首先收集依赖</li><li>接下来检查 <code>dirty</code>脏的状态，执行 <code>this.effect.run()!</code></li><li>获取最新值，返回</li></ol></li><li>第二次进入： <ol><li>进入 <code>computed</code> 的 <code>get value</code> ：</li><li>首先收集依赖</li><li>接下来检查 <code>dirty</code>脏的状态，**因为在上一次中 <code>dirty</code> 已经为 <code>false</code> **，所以本次 <strong>不会在触发 <code>this.effect.run()!</code></strong></li><li>直接返回结束</li></ol></li></ol></li><li><p>**按说代码应该到这里就结束了，**但是不要忘记，在刚才我们进入到 <code>triggerEffects</code> 时，<code>effets</code> 是一个数组，内部还存在一个 <strong><code>computed</code> 的 <code>effect</code></strong>，所以代码会 <strong>继续</strong> 执行，再次来到 <code>triggerEffect</code> 中：</p><ol><li>此时 <code>effect</code> 为 <code>computed</code> 的 <code>effect</code>：</li></ol><p><img src="https://qn.huat.xyz/mac/202403022302565.jpg" alt="图片描述"></p><ol start="2"><li>这会导致，再次触发 <code>scheduler</code>，</li><li><code>scheduler</code> 中还会再次触发 <code>triggerRefValue</code></li><li><code>triggerRefValue</code> 又触发 <code>triggerEffects</code> ，<strong>再次生成一个新的 <code>effects</code> 包含两个 <code>effect</code></strong>，就像 <strong>第七步</strong> 一样</li><li>从而导致 <strong>死循环</strong></li></ol></li></ol><p>以上逻辑就是为什么会出现死循环的原因。</p><p>那么明确好了导致死循环的代码逻辑之后，接下来就是如何解决这个死循环的问题呢？</p><blockquote><p>PS：这里大家要注意： <code>vue3-mini</code> 是一个学习 <code>vue 3</code> 核心源代码的库，所以它在一些复杂业务中会存在各种 <code>bug</code>。而这样的 <code>bug</code> 在 <code>vue3</code> 的源码中处理完善的逻辑非常非常复杂，我们不可能完全按照 <code>vue 3</code> 的标准来去处理。</p><p>所以我们秉承着 <strong>最少代码的实现逻辑</strong> 来解决对应的 <code>bug</code>，它 <strong>并不是一个完善的方案（相比于 <code>vue 3</code> 源代码）</strong>，但是 <strong>它是 <code>vue 3</code> 的源码逻辑，并且是合理的！</strong></p></blockquote><h3 id="如何解决死循环" tabindex="-1">如何解决死循环 <a class="header-anchor" href="#如何解决死循环" aria-label="Permalink to &quot;如何解决死循环&quot;">​</a></h3><p>想要解决这个死循环的问题，其实比较简单，我们只需要在 <code>packages/reactivity/src/effect.ts</code> 中的 <code>triggerEffects</code> 中修改如下代码：</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">triggerEffects</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">dep</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Dep</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 把 dep 构建为一个数组</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">effects</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">isArray</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">dep</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">?</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">dep</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> [</span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">dep</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 依次触发</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// for (const effect of effects) {</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 	triggerEffect(effect)</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 不在依次触发，而是先触发所有的计算属性依赖，再触发所有的非计算属性依赖</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">effect</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">of</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">effects</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">effect</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">computed</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">triggerEffect</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">effect</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">effect</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">of</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">effects</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">effect</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">computed</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">triggerEffect</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">effect</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>那么为什么这样就可以解决死循环的 <code>bug</code> 呢？</p><p>我们再按照刚才的顺序跟踪下代码进行查看：</p><ol><li><p>为 <code>packages/reactivity/src/effect.ts</code> 中的 <code>trigger</code> 方法增加断点，延迟两秒之后，进入断点：</p></li><li><p>此时执行的代码是 <code>obj.name = &#39;李四&#39;</code>，所以在 <code>target</code> 为 <code>{name: &#39;李四&#39;}</code></p></li><li><p>但是要 <strong>注意</strong>，此时 <code>targetMap</code> 中，已经在 <strong>收集过 <code>effect</code></strong> 了，此时的 <code>dep</code> 中包含一个 <strong>计算属性</strong>的 <code>effect</code></p></li><li><p>代码继续向下进行，进入 <code>triggerEffects(dep)</code> 方法</p></li><li><p>在 <code>triggerEffects(dep)</code> 方法中，继续进入 <code>triggerEffect(effect)</code></p></li><li><p>在 <code>triggerEffect</code> 中接收到的 <code>effect</code>，即为刚才查看的 <strong>计算属性的 <code>effect</code>：</strong></p></li></ol><p><img src="https://qn.huat.xyz/mac/202403022302808.jpg" alt="图片描述"></p><ol start="7"><li><p>此时因为 <code>effect</code> 中存在 <code>scheduler</code>，所以会执行该计算属性的 <code>scheduler</code> 函数，在 <code>scheduler</code> 函数中，会触发 <code>triggerRefValue(this)</code>，而 <code>triggerRefValue</code> 则会再次触发 <code>triggerEffects</code></p></li><li><p><strong>---------------不同从这里开始---------------：</strong></p></li><li><p>因为此时我们在 <code>triggerEffects</code> 中，增加了 <strong>判断逻辑</strong>，所以 <strong>永远会先触发</strong> 计算属性的 <code>effect</code></p></li><li><p>所以此时再次进入到 <code>triggerEffect</code> 时，此时的 <code>effect</code> 依然为 <strong>计算属性的 <code>effect</code>：</strong></p></li></ol><p><img src="https://qn.huat.xyz/mac/202403022302841.jpg" alt="图片描述"></p><ol start="11"><li><p>从而因为存在 <code>scheduler</code>，所以会执行：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">			</span><span style="color:#676E95;font-style:italic;">// 判断当前脏的状态，如果为 false，表示需要《触发依赖》</span></span>
<span class="line"><span style="color:#F07178;">			</span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!this.</span><span style="color:#A6ACCD;">_dirty</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">				</span><span style="color:#676E95;font-style:italic;">// 将脏置为 true，表示</span></span>
<span class="line"><span style="color:#F07178;">				</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">_dirty</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F07178;">				</span><span style="color:#82AAFF;">triggerRefValue</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">			</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li><li><p>但是此时要注意：<strong>此时 _dirty 脏的状态</strong> 为 <code>true</code>，即：<strong>不会触发 <code>triggerRefValue</code> 来触发依赖</strong>，此次计算属性的 <code>scheduler</code> 调度器会 <strong>直接结束</strong></p></li><li><p>然后代码 <strong>跳回到 <code>triggerEffects</code> 两次循环中</strong>，使用 <strong>非计算属性的 <code>effect</code></strong> 执行 <code>triggerEffect</code> 方法</p></li><li><p>本次进入 <code>triggerEffect</code> 时，<code>effect</code> 数据如下：</p></li></ol><p><img src="https://qn.huat.xyz/mac/202403022302019.jpg" alt="图片描述"></p><ol start="15"><li><p>那么这次 <code>run</code> 的执行会触发 <strong>两次 <code>computed</code> 的 <code>get value</code></strong></p></li><li><p>所以代码会进入到 <code>computed</code> 的 <code>get value</code> 中：</p><ol><li>第一次进入： <ol><li>进入 <code>computed</code> 的 <code>get value</code> ：</li><li>首先收集依赖</li><li>接下来检查 <code>dirty</code>脏的状态，执行 <code>this.effect.run()!</code></li><li>获取最新值，返回</li></ol></li><li>第二次进入： <ol><li>进入 <code>computed</code> 的 <code>get value</code> ：</li><li>首先收集依赖</li><li>接下来检查 <code>dirty</code>脏的状态，**因为在上一次中 <code>dirty</code> 已经为 <code>false</code> **，所以本次 <strong>不会在触发 <code>this.effect.run()!</code></strong></li><li>直接返回结束</li></ol></li></ol></li></ol><p>所有代码逻辑结束。</p><p>查看测试实例的打印，<code>computed</code> 只计算了一次。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>那么到这里我们就解决了计算属性的死循环问题和缓存的问题。</p><p>其实解决的方式非常的简单，我们只需要控制 <code>computed</code> 的 <code>effect</code> 和 <code>非 computed</code> 的 <code>effect</code> 的执行顺序，通过明确的 <code>dirty</code> 来控制 <code>run</code> 和 <code>triggerRefValue</code> 的执行即可。</p>`,39),p=[l];function c(t,r,d,i,y,F){return e(),n("div",null,p)}const g=s(a,[["render",c]]);export{u as __pageData,g as default};
