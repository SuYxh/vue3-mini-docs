import{_ as s,c as n,o as a,Q as l}from"./chunks/framework.5f28ab71.js";const C=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"framework-design/10-运行时+编译时.md","lastUpdated":1709451841000}'),o={name:"framework-design/10-运行时+编译时.md"},p=l(`<h2 id="_10-运行时-编译时" tabindex="-1">10-运行时 + 编译时 <a class="header-anchor" href="#_10-运行时-编译时" aria-label="Permalink to &quot;10-运行时 + 编译时&quot;">​</a></h2><p>之前已经了解了 <strong>运行时 和 编译时</strong>，同时我们也知道了：<strong>vue 是一个 运行时+编译时</strong> 的框架！</p><blockquote><p><code>vue</code> 通过 <code>compiler</code> 解析 <code>html</code> 模板，生成 <code>render</code> 函数，然后通过 <code>runtime</code> 解析 <code>render</code>，从而挂载真实 <code>dom</code>。</p></blockquote><p>那么看到这里可能有些同学就会有疑惑了，既然 <strong>compiler 可以直接解析 html 模板</strong>，那么为什么还要生成 <code>render</code> 函数，然后再去进行渲染呢？为什么不直接利用 <code>compiler</code> 进行渲染呢？</p><p>即：<strong>为什么 vue 要设计成一个 运行时+编译时的框架呢？</strong></p><p>那么想要理清楚这个问题，我们就需要知道 <strong>dom 渲染是如何进行的。</strong></p><p>对于 <code>dom</code> 渲染而言，可以被分为两部分：</p><ol><li><strong>初次渲染</strong> ，我们可以把它叫做 <strong>挂载</strong></li><li><strong>更新渲染</strong> ，我们可以把它叫做 <strong>打补丁</strong></li></ol><h3 id="初次渲染" tabindex="-1">初次渲染 <a class="header-anchor" href="#初次渲染" aria-label="Permalink to &quot;初次渲染&quot;">​</a></h3><p>那么什么是初次渲染呢？</p><p>当初始 <code>div</code> 的 <code>innerHTML</code> 为空时，</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">app</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>我们在该 <code>div</code> 中渲染如下节点：</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">2</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">3</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>那么这样的一次渲染，就是 <strong>初始渲染</strong>。在这样的一次渲染中，我们会生成一个 <code>ul</code> 标签，同时生成三个 <code>li</code> 标签，并且把他们挂载到 <code>div</code> 中。</p><h3 id="更新渲染" tabindex="-1">更新渲染 <a class="header-anchor" href="#更新渲染" aria-label="Permalink to &quot;更新渲染&quot;">​</a></h3><p>那么此时如果 <code>ul</code> 标签的内容发生了变化：</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">3</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">2</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>li - 3</code> 上升到了第一位，那么此时大家可以想一下：<strong>我们期望浏览器如何来更新这次渲染呢？</strong></p><p>浏览器更新这次渲染无非有两种方式：</p><ol><li>删除原有的所有节点，重新渲染新的节点</li><li>删除原位置的 <code>li - 3</code>，在新位置插入 <code>li - 3</code></li></ol><p>那么大家觉得这两种方式哪一种方式更好呢？那么我们来分析一下：</p><ol><li>首先对于第一种方式而言：它的好处在于不需要进行任何的比对，需要执行 6 次（删除 3 次，重新渲染 3 次）<code>dom</code> 处理即可。</li><li>对于第二种方式而言：在逻辑上相对比较复杂。他需要分成两步来做： <ol><li>对比 <strong>旧节点</strong> 和 <strong>新节点</strong> 之间的差异</li><li>根据差异，删除一个 <strong>旧节点</strong>，增加一个 <strong>新节点</strong></li></ol></li></ol><p>那么根据以上分析，我们知道了：</p><ol><li>第一种方式：会涉及到更多的 <code>dom</code> 操作</li><li>第二种方式：会涉及到 <code>js</code> 计算 + 少量的 <code>dom</code> 操作</li></ol><p>那么这两种方式，哪一种更快呢？我们来实验一下：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> length </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10000</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 增加一万个dom节点，耗时 3.992919921875 ms</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">time</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">element</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> (</span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> length</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newEle</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">body</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newEle</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">timeEnd</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">element</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 增加一万个 js 对象，耗时 0.402099609375 ms</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">time</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> divList </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> []</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> (</span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> length</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newEle</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    type</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">divList</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newEle</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">timeEnd</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>从结果可以看出，<code>dom</code> 的操作要比 <code>js</code> 的操作耗时多得多，即：<strong><code>dom</code> 操作比 <code>js</code> 更加耗费性能</strong>。</p><p>那么根据这样的一个结论，回到我们刚才所说的场景中：</p><p>1、首先对于第一种方式而言：它的好处在于不需要进行任何的比对，仅需要执行 6 次（删除 3 次，重新渲染 3 次）<code>dom</code> 处理即可。</p><p>2、对于第二种方式而言：在逻辑上相对比较复杂。他需要分成两步来做：</p><ol><li>对比 <strong>旧节点</strong> 和 <strong>新节点</strong> 之间的差异</li><li>根据差异，删除一个 <strong>旧节点</strong>，增加一个 <strong>新节点</strong></li></ol><p>根据结论可知：<strong>方式一会比方式二更加消耗性能（即：性能更差）。</strong></p><p>那么得出这样的结论之后，我们回过头去再来看最初的问题：<strong>为什么 vue 要设计成一个 运行时+编译时的框架呢？</strong></p><p>1、针对于 <strong>纯运行时</strong> 而言：因为不存在编译器，所以我们只能够提供一个复杂的 <code>JS</code> 对象。</p><p>2、针对于 <strong>纯编译时</strong> 而言：因为缺少运行时，所以它只能把分析差异的操作，放到 <strong>编译时</strong> 进行，同样因为省略了运行时，所以速度可能会更快。但是这种方式这将损失灵活性（点击 <a href="https://v3.cn.vuejs.org/guide/render-function.html#%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0" target="_blank" rel="noreferrer">这里</a> 查看官方示例）。比如 <a href="https://www.sveltejs.cn/" target="_blank" rel="noreferrer">svelte</a> ，它就是一个纯编译时的框架，但是它的实际运行速度可能达不到理论上的速度。</p><p>3、<strong>运行时 + 编译时</strong>：比如 <code>vue</code> 或 <code>react</code> 都是通过这种方式来进行构建的，使其可以在保持灵活性的基础上，尽量的进行性能的优化，从而达到一种平衡。</p>`,37),e=[p];function t(r,c,D,F,i,y){return a(),n("div",null,e)}const A=s(o,[["render",t]]);export{C as __pageData,A as default};
