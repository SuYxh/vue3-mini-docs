import{_ as e,c,o,Q as d}from"./chunks/framework.5f28ab71.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"reactivity/reactive/02-源码阅读reactive的响应性.md","lastUpdated":1709451841000}'),t={name:"reactivity/reactive/02-源码阅读reactive的响应性.md"},l=d('<h2 id="_02-源码阅读-reactive-的响应性" tabindex="-1">02-源码阅读 reactive 的响应性 <a class="header-anchor" href="#_02-源码阅读-reactive-的响应性" aria-label="Permalink to &quot;02-源码阅读 reactive 的响应性&quot;">​</a></h2><p>我们知道在 <code>vue</code> 中想要实现响应式数据，拥有两种方式：</p><ol><li><code>reactive</code></li><li><code>ref</code></li></ol><p>在之前创建了 <code>packages/vue/examples/imooc/reactive.html</code> 测试实例，在该实例中，我们通过 <code>reactive</code> 方法声明了一个响应式数据，通过 <code>effect</code> 注册了一个函数。</p><p>那么下面，我们就 <strong>跟踪</strong> 当前的代码，来详细看一下 <code>vue</code> 内容到底做了什么？</p><p>看的过程中我们需要时刻记住两点主线：</p><ol><li><code>reactive</code> 做了什么？</li><li><code>effect</code> 是什么？</li></ol><p>明确好了之后，那么下面我们来去看：</p><h3 id="reactive-方法" tabindex="-1">reactive 方法 <a class="header-anchor" href="#reactive-方法" aria-label="Permalink to &quot;reactive 方法&quot;">​</a></h3><ol><li>触发 <code>reactive</code> 方法</li><li>创建 <code>reactive</code> 对象： <code>return createReactiveObject</code></li><li>进入<code>new Proxy</code><ol><li>第一个参数 <code>target</code>：为传入的对象</li><li>第二个参数 <code>handler</code>：<code>TargetType.COLLECTION = 2</code>，<code>targetType = 1</code>，所以 <code>handler</code> 为 <code>baseHandlers</code></li><li>那这个 <code>baseHandlers</code> 是什么呢？</li></ol></li><li>在 <code>reactive</code> 方法中可知，<code>baseHandlers</code> 是触发 <code>createReactiveObject</code> 传递的第三个参数：<code>mutableHandlers</code></li><li>而 <code>mutableHandlers</code> 则是 <code>packages/reactivity/src/baseHandlers.ts</code> 中导出的对象</li><li>所以我们到 <code>packages/reactivity/src/baseHandlers.ts</code> 中，为它的 <code>get（createGetter）</code> 和 <code>set（createSetter）</code> 分别打入一个断点</li><li>我们知道 <code>get</code> 和 <code>set</code> 会在 <strong>取值</strong> 和 <strong>赋值</strong> 时触发，所以此时这两个断点 <strong>不会执行</strong></li><li>最后 <code>reactive</code> 方法内执行了 <code>proxyMap.set(target, proxy)</code> 方法</li><li>最后返回了代理对象。</li><li>那么至此 <code>reactive</code> 方法执行完成。</li></ol><p>由以上执行逻辑可知，对于 <code>reactive</code> 方法而言，其实做的事情非常简单：</p><ol><li>创建了 <code>proxy</code></li><li>把 <code>proxy</code> 加到了 <code>proxyMap</code> 里面</li><li>最后返回了 <code>proxy</code></li></ol><h3 id="effect" tabindex="-1">effect <a class="header-anchor" href="#effect" aria-label="Permalink to &quot;effect&quot;">​</a></h3><p>那么接下来我们 <code>effect</code>：</p><ol><li>在 <code>packages/reactivity/src/effect.ts</code> 第 <code>170</code> 行左右可以找到 <code>effect</code> 方法，在这里给一个断点</li><li>执行<code>new ReactiveEffect(fn)</code>，其中的<code>fn</code>就是我们传入的匿名函数： <ol><li>这里涉及到了一个类 <code>ReactiveEffect</code></li><li>查看该类可知，内部实现了两个方法： <ol><li><code>run</code></li><li><code>stop</code></li></ol></li><li>我们分别为这两个方法 <strong>增加断点</strong></li></ol></li><li>代码继续进行</li><li>可以发现执行了<code>run</code>方法，进入方法内部： <ol><li>执行 <code>activeEffect = this</code>，赋值完成之后，<code>activeEffect</code> 为 <strong>传入的匿名函数 <code>fn</code></strong></li><li>然后执行 <code>return this.fn()</code> 触发 <code>fn</code> 函数</li><li>我们知道 <code>fn</code> 函数其实就是 <strong>传入的匿名函数</strong>，所以 <code>document.querySelector(&#39;#app&#39;).innerText = obj.name</code></li></ol></li><li>但是大家不要忘记，<code>obj</code>是一个<code>proxy</code>，<code>obj.name</code>会触发 <code>getter</code>，所以接下来我们就会进入到<code>mutableHandlers</code>的<code>createGetter</code>中 <ol><li>在该代码中，触发了该方法 <code>const res = Reflect.get(target, key, receiver)</code></li><li>此时的 <code>res</code> 即为 <code>张三</code></li><li>注意接下来触发了<code>track</code>函数，该函数是一个重点函数，<code>track</code>在此为跟踪的意思，我们来看它内部都做了什么： <ol><li>在 <code>4-1</code> 步中，为 <code>activeEffect</code> 进行了赋值，我们知道 <code>activeEffect</code> 代表的就是 <code>fn</code> 函数</li><li>执行代码可知，<code>track</code>内部主要做了两件事情： <ol><li>为<code>targetMap</code>进行赋值，<code>targetMap</code>的组成比较复杂： <ol><li><code>key</code>：<code>target</code></li><li><code>value</code>: <code>Map</code><ol><li><code>key</code>：<code>key</code></li><li><code>value</code>：<code>Set</code></li></ol></li></ol></li><li>最后执行了<code>trackEffects(dep, eventInfo)</code><ol><li>其中 <code>eventInfo</code> 是一个对象，内部包含四个属性：<strong>其中 <code>effect</code> 即为 <code>activeEffect</code> 即 <code>fn</code> 函数</strong></li></ol></li><li>在<code>trackEffects</code>函数内部，核心也是做了两件事情： <ol><li>为 <code>dep（targetMap[target][key]）</code>得到的 Set 实例添加了 <code>activeEffect</code> 函数</li><li>为 <code>activeEffect</code> 函数的 <strong>静态属性</strong> <code>deps</code>，增加了一个值 <code>dep</code></li><li>即：<strong>建立起了 <code>dep</code> 和 <code>activeEffect</code> 的联系</strong></li></ol></li></ol></li></ol></li><li>那么至此，整个 <code>track</code> 的核心逻辑执行完成</li><li>我们可以把整个 <code>track</code> 的核心逻辑说成：<strong>收集了 <code>activeEffect（即：fn）</code></strong></li></ol></li><li>最后在 <code>createGetter</code> 函数中返回了 <code>res（即：张三）</code></li><li>至此，整个 <code>effect</code> 执行完成</li></ol><p>由以上逻辑可知，整个 <code>effect</code> 主要做了 3 件事情：</p><ol><li>生成 <code>ReactiveEffect</code> 实例</li><li>触发 <code>fn</code> 方法，从而激活 <code>getter</code></li><li>建立了<code>targetMap</code>和<code>activeEffect</code>之间的联系 <ol><li><code>dep.add(activeEffect)</code></li><li><code>activeEffect.deps.push(dep)</code></li></ol></li></ol><p>那么至此：**页面中即可展示 <code>obj.name</code> **，但是不要忘记，等待两秒之后，我们会修改 <code>obj.name</code> 的值，我们知道，这样会触发 <code>setter</code>，那么我们接下来来看 <code>setter</code> 中又做了什么呢？</p><ol><li><p>两秒之后触发 <code>setter</code>，会进入到 <code>packages/reactivity/src/baseHandlers.ts</code> 中的的 <code>createSetter</code> 方法中</p></li><li><p>创建变量： <code>oldValue = 张三</code></p></li><li><p>创建变量：<code>value = 李四</code>、</p></li><li><p>执行 <code>const result = Reflect.set(target, key, value, receiver)</code>，即：修改了 <code>obj</code> 的值为 “李四”</p></li><li><p>触发：<code>trigger(target, TriggerOpTypes.SET, key, value, oldValue)</code>，此时各参数的值为：</p></li></ol><p><img src="https://qn.huat.xyz/mac/202403021936182.jpg" alt="图片描述"></p><ol start="6"><li><p><code>trigger</code> 在这里为 <strong>触发</strong> 的意思，那么我们来看 <code>trigger</code> 内部做了什么？</p><ol><li><p>首先执行：<code>const depsMap = targetMap.get(target)</code> ，其中 <code>targetMap</code> 即我们在 <code>track</code> 函数中，保存 <code>activeEffect</code> 的 <code>targetMap</code></p></li><li><p>然后代码执行到：<code>deps.push(depsMap.get(key))</code>。<code>depsMap.get(key)</code> 获取到的即为之前保存的 <code>activeEffect</code>，即 <code>fn</code> 函数</p></li><li><p>然后触发 <code>triggerEffects(deps[0], eventInfo)</code>，我们来看 <code>triggerEffects</code> 中做了什么：</p><ol><li><p>声明常量：<code>const effects = isArray(dep) ? dep : [...dep]</code>，此时的 <code>effects</code> 保存的为 <code>fn</code> 的集合</p></li><li><p>遍历 <code>effects</code>，执行：<code>triggerEffect(effect, debuggerEventExtraInfo)</code> 方法，那么我们来看 <code>triggerEffect</code> 做了什么</p><ol><li><p>执行 <code>effect.run()</code> 方法，已知：<code>effect</code> 是一个 <code>ReactiveEffect</code> 类型的对象，则 <code>run</code> 方法会触发 <code>ReactiveEffect</code> 的 <code>run</code>，那么我们接下来来看 <strong>这一次</strong> 进入 <code>run</code> 方法时，内部做了什么？</p><ol><li><p>首先还是为 <code>activeEffect = this</code> 赋值，但是要 <strong>注意：</strong> 此时的 <code>this</code> 不再是一个 <code>fn</code>，而是一个复杂对象：</p><p><img src="https://qn.huat.xyz/mac/202403021936369.jpg" alt="图片描述"></p></li><li><p>最后执行 <code>this.fn()</code> 即：<code>effect 时传入的匿名函数</code></p></li><li><p>至此，<code>fn</code> 执行，意味着： <code>document.querySelector(&#39;#app&#39;).innerText = 李四</code>，页面将发生变化</p></li></ol></li></ol></li><li><p><code>triggerEffect</code> 完成</p></li></ol></li><li><p><code>triggerEffects</code> 完成</p></li></ol></li><li><p><code>trigger</code> 完成</p></li><li><p><code>setter</code> 回调完成</p></li></ol><p>由以上逻辑可知，整个 <code>setter</code> 主要做了 2 件事情：</p><ol><li>修改 <code>obj</code> 的值</li><li>触发 <code>targetMap</code> 下保存的 <code>fn</code> 函数</li></ol><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>那么到这里，我们就整个的跟踪了 <code>packages/vue/examples/imooc/reactive.html</code> 实例中：</p><ol><li><code>reactive</code> 函数</li><li><code>effect</code> 函数</li><li><code>obj.name = xx</code> 表达式</li></ol><p>这三块代码背后，<code>vue</code> 究竟都做了什么。虽然整个的过程比较复杂，但是如果我们简单来去看，其实内部的完成还是比较简单的：</p><ol><li>创建 <code>proxy</code></li><li>收集 <code>effect</code> 的依赖</li><li>触发收集的依赖</li></ol>',28),i=[l];function a(r,p,s,f,n,g){return o(),c("div",null,i)}const h=e(t,[["render",a]]);export{u as __pageData,h as default};
