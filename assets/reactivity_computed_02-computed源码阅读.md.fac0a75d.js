import{_ as e,c as s,o,Q as l}from"./chunks/framework.5f28ab71.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"reactivity/computed/02-computed源码阅读.md","lastUpdated":1709451841000}'),n={name:"reactivity/computed/02-computed源码阅读.md"},a=l(`<h2 id="_02-computed-源码阅读" tabindex="-1">02-computed 源码阅读 <a class="header-anchor" href="#_02-computed-源码阅读" aria-label="Permalink to &quot;02-computed 源码阅读&quot;">​</a></h2><blockquote><p>计算属性 <code>computed</code> 会 <strong>基于其响应式依赖被缓存</strong>，并且在依赖的响应式数据发生变化时 <strong>重新计算</strong></p></blockquote><p>那么根据计算属性的概念，我们可以创建对应的测试实例：<code>packages/vue/examples/imooc/computed.html</code>：</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> reactive</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> computed</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> effect </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Vue</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">张三</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> computedObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">computed</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">姓名：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">effect</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">#app</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerHTML</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">computedObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">李四</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2000</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>在以上测试实例中，程序主要执行了 5 个步骤：</p><ol><li>使用 <code>reactive</code> 创建响应性数据</li><li>通过 <strong><code>computed</code></strong> 创建计算属性 <code>computedObj</code>，并且触发了 <code>obj</code> 的 <code>getter</code></li><li>通过 <code>effect</code> 方法创建 <code>fn</code> 函数</li><li>在 <code>fn</code> 函数中，触发了 <code>computed</code> 的 <code>getter</code></li><li>延迟触发了 <code>obj</code> 的 <code>setter</code></li></ol><p>那么在这 5 个步骤中，有些步骤进行的操作我们是了解的，所以我们只需要看之前没有了解过得即可。</p><h3 id="computed" tabindex="-1">computed <a class="header-anchor" href="#computed" aria-label="Permalink to &quot;computed&quot;">​</a></h3><p><code>computed</code> 的代码在 <code>packages/reactivity/src/computed.ts</code> 中，我们可以在这里为 <code>computed</code> 函数增加断点：</p><ol><li><p>代码进入 <code>computed</code> 函数</p></li><li><p>执行 <code>const onlyGetter = isFunction(getterOrOptions)</code> 方法：</p><ol><li><code>getterOrOptions</code> 为传入的第一个参数， 因为我们传入的为函数，所以 <code>onlyGetter = true</code></li></ol></li><li><p>执行：<code>getter = getterOrOptions</code> ，即：<code>getter</code> 为我们传入的函数</p></li><li><p>执行：<code>setter = NOOP</code>，<code>NOOP</code> 为 <code>() =&gt; {}</code></p></li><li><p>执行：<code>new ComputedRefImpl</code>，<strong>创建 <code>ComputedRefImpl</code> 实例</strong>。那么这里的 <code>ComputedRefImpl</code> 是什么呢？</p></li><li><p>进入 <code>ComputedRefImpl</code></p><ol><li><p>在构造函数中，可以看到：**创建了 <code>ReactiveEffect</code> 实例 **，并且传入了两个参数：</p><ol><li><p><code>getter</code>：触发 <code>computed</code> 函数时，传入的第一个参数</p></li><li><p>匿名函数：当 <code>this._dirty</code> 为 <code>false</code> 时，会触发 <code>triggerRefValue</code>，我们知道 <code>triggerRefValue</code> 会 <strong>依次触发依赖</strong></p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// _dirty 表示 “脏” 的意思，这里可以理解为依赖的响应性数据发生了变化，计算属性需要重新计算了</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!this.</span><span style="color:#A6ACCD;">_dirty</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">_dirty</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">triggerRefValue</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ol></li><li><p>而对于 <code>ReactiveEffect</code> 而言，我们之前也是有了解过的：</p><ol><li>它位于 <code>packages/reactivity/src/effect.ts</code> 文件中</li><li>提供了一个<code>run</code>方法 和一个 <code>stop</code>方法： <ol><li><code>run</code> 方法：触发 <code>fn</code>，即传入的第一个参数</li><li><code>stop</code> 方法：语义上为停止的意思，目前咱们还没有实现</li></ol></li><li>生成的实例，我们一般把它叫做 <code>effect</code></li></ol></li><li><p>执行 <strong><code>this.effect.computed = this</code></strong>，即：<strong>effect 实例</strong> 被挂载了一个新的属性 <code>computed</code> 为当前的 <code>ComputedRefImpl</code> 的实例。</p></li><li><p><strong><code>ReactiveEffect</code> 构造函数执行完成</strong></p></li></ol></li><li><p>在 <code>computed</code> 中返回了 <code>ComputedRefImpl</code> 实例</p></li></ol><p>由以上代码可知，当我们在执行 <code>computed</code> 函数时：</p><ol><li>定义变量 <code>getter</code> 为我们传入的回调函数</li><li>生成了 <code>ComputedRefImpl</code> 实例，作为 <code>computed</code> 函数的返回值</li><li><code>ComputedRefImpl</code> 内部，利用了 <code>ReactiveEffect</code> 函数，并且传入了 <strong>第二个参数</strong></li></ol><h3 id="computed-的-getter" tabindex="-1">computed 的 getter <a class="header-anchor" href="#computed-的-getter" aria-label="Permalink to &quot;computed 的 getter&quot;">​</a></h3><p>当 <code>computed</code> 代码执行完成之后，我们在 <code>effect</code> 中触发了 <code>computed</code> 的 <code>getter</code>：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">computedObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>根据我们之前在学习 <code>ref</code> 的时候可知，<code>.value</code> 属性的调用本质上是一个 <strong><code>get value</code> 的函数调用</strong>，而 <code>computedObj</code> 作为 <code>computed</code> 的返回值，本质上是 <code>ComputedRefImpl</code> 的实例， 所以此时会触发 <code>ComputedRefImpl</code> 下的 <code>get value</code> 函数。</p><ol><li><p>进入<code>ComputedRefImpl</code> 下的 <code>get value</code> 函数</p></li><li><p>执行 <code>trackRefValue(self)</code> ，该方法我们是有过了解的，知道它的作用是：<strong>收集依赖</strong>，它接收一个 <code>ref</code> 作为参数，该 <code>ref</code> 本质上就是 <code>ComputedRefImpl</code> 的实例：</p><p><img src="https://qn.huat.xyz/mac/202403022237398.jpg" alt="图片描述"></p></li><li><p>执行 <code>self._dirty = false</code> ，我们知道 <code>_dirty</code> 是 <strong>脏</strong> 的意思，如果 <code>_dirty = true</code> 则会 <strong>触发执行依赖</strong> 。在 <strong>当前（标记为 <code>false</code> 之前）</strong>，<code>self._dirty = true</code></p></li><li><p>所以接下来执行 <code>self.effect.run()!</code>，执行了 <code>run</code> 方法，我们知道 <code>run</code> 方法内部其实会触发 <code>fn</code> 函数，即：<strong><code>computed</code>接收的第一个参数</strong></p></li><li><p>接下来把 <code>self._value = self.effect.run()!</code> ，此时 <code>self._value</code> 的值为 <code>computed</code> 第一个参数（<code>fn</code> 函数）的返回值， 即为：<strong>计算属性计算之后的值</strong></p></li><li><p>最后执行 <code>return self._value</code>，返回计算的值</p></li></ol><p>由以上代码可知：</p><ol><li><code>ComputedRefImpl</code> 实例本身就没有 <strong>代理监听</strong>，它本质上是一个 <code>get value</code> 和 <code>set value</code> 的触发</li><li>在每一次 <code>get value</code> 被触发时，都会主动触发一次 <strong>依赖收集</strong></li><li>根据 <code>_dirty 和 _cacheable</code> 的状态判断，是否需要触发 <code>run</code> 函数</li><li><code>computed</code> 的返回值，其实是 <code>run</code> 函数执行之后的返回值</li></ol><h3 id="reactiveeffect-的-scheduler" tabindex="-1">ReactiveEffect 的 scheduler <a class="header-anchor" href="#reactiveeffect-的-scheduler" aria-label="Permalink to &quot;ReactiveEffect 的 scheduler&quot;">​</a></h3><p>到现在为止，我们貌似已经分析完成了 <code>computed</code> 的源码执行逻辑，但是大家仔细来看上面的逻辑分析，可以发现，目前这样的逻辑还存在一些问题。</p><p>我们知道对于计算属性而言，当它依赖的响应式数据发生变化时，它将重新计算。那么换句话而言就是：<strong>当响应性数据触发 <code>setter</code> 时，计算属性需要触发依赖</strong>。</p><p>在上面的代码中，我们知道，当每一次 <code>get value</code> 被触发时，都会主动触发一次 <strong>依赖收集</strong>，但是 <strong>触发依赖</strong> 的地方在哪呢？</p><p>根据以上代码可知：在 <code>ComputedRefImpl</code> 的构造函数中，我们创建了 <code>ReactiveEffect</code> 实例，并且传递了第二个参数，该参数为一个回调函数，在这个回调函数中：我们会根据 <strong>脏</strong> 的状态来执行 <code>triggerRefValue</code> ，即 <strong>触发依赖</strong>，重新计算。</p><p>那么这个 <strong><code>ReactiveEffect</code> 第二个参数</strong> 是什么呢？它会在什么时候被触发，以 <strong>触发依赖</strong> 呢？</p><p>我们来看一下：</p><ol><li><p>进入 <code>packages/reactivity/src/effect.ts</code> 中</p></li><li><p>查看 <code>ReactiveEffect</code> 的构造函数，可以第二个参数为 <code>scheduler</code></p></li><li><p><code>scheduler</code> 表示 <strong>调度器</strong> 的意思，我们查看 <code>packages/reactivity/src/effect.ts</code> 中 <code>triggerEffect</code> 方法，可以发现这里进行了调度器的判定：</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">triggerEffect</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">...</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">effect</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">scheduler</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">effect</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">scheduler</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><p>那么接下来我们就可以跟踪一下代码的实现。</p></li></ol><h4 id="跟踪代码" tabindex="-1">跟踪代码 <a class="header-anchor" href="#跟踪代码" aria-label="Permalink to &quot;跟踪代码&quot;">​</a></h4><p>我们知道 <strong>延迟两秒之后</strong>，会触发 <code>obj.name</code> 即 <code>reactive</code> 的 <code>setter</code> 行为，所以我们可以在 <code>packages/reactivity/src/baseHandlers.ts</code> 中为 <code>set</code> 增加一个断点：</p><ol><li><p>进入 <code>reactive</code> 的 <code>setter</code> （注意：这里是延迟两秒之后 <code>setter</code> 行为）</p></li><li><p>跳过之前的相同逻辑之后，可知，最后会触发：<code>trigger(target, TriggerOpTypes.SET, key, value, oldValue)</code> 方法</p></li><li><p>进入 <code>trigger</code> 方法：</p></li><li><p>同样跳过之前相同逻辑，可知，最后会触发：<code>triggerEffects(deps[0], eventInfo)</code> 方法</p></li><li><p>进入 <code>triggerEffects</code> 方法：</p></li><li><p>这里要注意：因为我们在<code>ComputedRefImpl</code>的构造函数中，执行了<code>this.effect.computed = this</code>，所以此时的 <code>if (effect.computed)</code> 判断将会为 <code>true</code></p><ol><li><p>此时我们注意看 <code>effects</code>，此时 <code>effect</code> 的值为 <code>ReactiveEffect</code> 的实例，同时 <strong><code>scheduler</code> 存在值</strong> ：</p><p><img src="https://qn.huat.xyz/mac/202403022237522.jpg" alt="图片描述"></p></li><li><p>接下来进入<code>triggerEffect</code></p><ol><li><p>在 <code>triggerEffect</code> 中</p></li><li><p>执行 <code>if (effect.scheduler)</code> 判断，因为 <code>effect</code> 存在 <code>scheduler</code> ，所以会 <strong>执行 <code>scheduler</code> 函数</strong></p></li><li><p>此时会进入<code>ComputedRefImpl</code> 类的构造函数中，传递的回调函数</p><ol><li><p>进入 <strong><code>scheduler</code> 回调</strong></p></li><li><p>此时 <code>this</code> 的状态如下：</p></li></ol><p><img src="https://qn.huat.xyz/mac/202403022237657.jpg" alt="图片描述"></p></li><li><p>所以会执行<code>triggerRefValue</code>函数：</p><ol><li><p>进入 <code>triggerRefValue</code> 函数</p></li><li><p>会再次触发<code>triggerEffects</code>函数，把当前的<code>this.dep</code>作为参数传入</p><ol><li><p>再次进入 <code>triggerEffects</code></p></li><li><p><strong>注意：</strong> 此时的 <code>effects</code> 的值为：</p><pre><code>	![图片描述](https://qn.huat.xyz/mac/202403022249391.jpg)
</code></pre></li><li><p>这次的 <code>ReactiveEffect</code> <strong>不再包含</strong> 调度器</p></li><li><p>接下来进入<code>triggerEffect</code></p><ol><li><p>在 <code>triggerEffect</code> 因为 <code>effect</code> 不再包含调度器 <code>scheduler</code></p></li><li><p>所以会直接执行 <code>fn</code> 函数</p></li><li><p><code>fn</code> 函数的触发，标记着 <code>computedObj.value</code> 触发，而我们知道 <code>computedObj.value</code> 本质上是 <code>get value</code> 函数的触发，所以代码接下来会触发 <strong><code>ComputedRefImpl</code> 的 <code>get value</code></strong></p></li><li><p>接下来进入 <code>get value</code></p><ol><li><p>进入 <code>get value</code></p></li><li><p>执行 <code>self._value = self.effect.run()!</code>，而 <code>run</code> 函数的执行本质上是 <code>fn</code> 函数的执行，而此时 <code>fn</code> 函数为：</p><p><img src="https://qn.huat.xyz/mac/202403022251307.jpg" alt="图片描述"></p></li><li><p>执行该函数得到计算的值</p></li><li><p>最后作为 <code>computedObj.value</code> 的返回值</p></li><li><p>省略后续的触发…</p></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><p>至此，整个 <code>obj.name</code> 引发的副作用全部执行完成。</p><p>由以上代码可知，整个的计算属性的逻辑是非常复杂的，我们来做一下整理：</p><ol><li><p>整个事件有 <code>obj.name</code> 开始</p></li><li><p>触发 <code>proxy</code> 实例的 <code>setter</code></p></li><li><p>执行 <code>trigger</code>，<strong>第一次触发依赖</strong></p></li><li><p>注意，此时 <code>effect</code> 包含调度器属性，所以会触发调度器</p></li><li><p>调度器指向 <code>ComputedRefImpl</code> 的构造函数中传入的匿名函数</p></li><li><p>在匿名函数中会：<strong>再次触发依赖</strong></p></li><li><p>即：<strong>两次触发依赖</strong></p></li><li><p>最后执行 ：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">姓名：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>得到值作为 <code>computedObj</code> 的值</p></li></ol><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>那么到这里我们基本上了解了 <code>computed</code> 的执行逻辑，里面涉及到了一些我们之前没有了解过的概念，比如 <strong>调度器 <code>scheduler</code></strong> ，并且整体的 <code>computed</code> 的流程也相当复杂。</p>`,35),p=[a];function c(t,r,d,i,y,u){return o(),s("div",null,p)}const m=e(n,[["render",c]]);export{F as __pageData,m as default};
